#' qPCR analysis
#'
#' A function for the analysis of qPCR data using the "delta Ct" method.
#'
#' @param ct_data a data frame with the qPCR input data. It needs to have the following columns: names, cq, efficiency, primers, included.
#' @param type type of analysis, either \code{"rtqpcr"} or \code{"qchip"}. (NOTE: qchip analysis is not yet implemented)
#' @param design a data frame containing the experimental design, at least one expected column called "sample_name" which has to match
#' the sample names in \code{ct_data} and additional columns for each experimental condition relevant in the design.
#' @param calibsample a character string with the name of the sample to be used as reference for dct calculation. This sample will have an
#' expression value of 1 for all targets and the rest of the samples will have values expressing their relative expression to this sample.
#' @param hkg a character vector with the name of the "housekeeping" genes used for normalization.
#' @param exp_name a character string with the name of the experiment, which will be used to name the files and objects generated by the function
#' @param fix_names logical indicating whether the sample names need to be "fixed" (default = FALSE, only relevant if using files generated with chainy to remove well position, dots and asterisks from sample names).
#' @param exclude logical indicating whether the logical column "exclude" from the input should be used to filter the data frame (default = FALSE).
#' @param save_csv NOT USED YET logical indicating whether to save the final analyzed data frame as a csv file.
#'
#' @return a data frame with the analyzed qPCR data containing normalized dct values.
#' @export
#'
#' @examples
qpcr_analysis <- function( # MAIN FUNCTION
  ct_data, # Data frame, expected columns: names, cq, efficiency, primers, included
  type = "rtqpcr", # Analysis type, rtqpcr or qchip
  design, # Design matrix, at least one expected column "sample_name" and additional columns for each exp condition, for chip at least one has to be named IP
  calibsample, # String, name of the reference sample for dct calculation, will be 1 for all genes and the rest of the samples will be relative to it
  hkg, # Character vector with the "housekeeping" genes for normalization
  exp_name, # String, experiment name, will be used for naming saved files
  fix_names = FALSE, # Logical, fix names from chainy output if TRUE
  exclude = FALSE, # Logical, exclude samples with included = FALSE
  save_csv = TRUE # Logical save a csv file with the normalized data
) {

  # Fix names if ncessary (chainy output), otherwise keep as is

  if (fix_names) {
    ct_data$sample <- sapply(as.character(ct_data$names), fix_names, USE.NAMES = F)
  } else {
    ct_data$sample <- ct_data$names
  }

  # Exclude samples if necessary

  if (exclude) {
    ct_data <- ct_data[ct_data$included == TRUE,]
  }

  # Average ct of technical replicates

  ct_avg <- ct_avg_fun(ct_data)

  # Calculate median efficieny and average ct per primer pair

  eff <- aggregate(ct_avg$effaverage, by = ct_avg["primers"], FUN = median, na.rm = T)
  names(eff)[2] <- "efficiency"
  print(eff)
  ct <- aggregate(ct_data$cq, by = ct_data["primers"], FUN = mean, na.rm = T)
  names(ct)[2] <- "cq"
  save(eff, file =  paste0(exp_name, "_eff.RData"))
  write.csv(eff, paste0(exp_name, "_eff.csv"))
  save(ct, file = paste0(exp_name, "_ct.RData"))
  write.csv(ct, paste0(exp_name, "_ct.csv"))


  if (type == "rtqpcr") {

    # Calculate dct for the data

    dct_data <- dct_apply(ct_avg, calibsample, eff)

    # Normalization factor calculation

    norm_factor <- norm_factor_fun(dct_data, hkg, exp_name)

    # Normalize dct values

    norm_dct <- apply(dct_data, 1, function(x) as.numeric(x["dct"]) / norm_factor[as.character(x["sample"])])
    norm_data <- cbind(dct_data, "norm_dct" = norm_dct)
    write.csv(norm_data, file = paste0(exp_name, "_norm_data.csv"))

    # Create QC plots
    ct_sd_plot(norm_data, exp_name = exp_name)
    ct_avg_plot(norm_data, exp_name = exp_name)
    eff_avg_plot(norm_data, exp_name = exp_name)

    return(norm_data)
  }
}
